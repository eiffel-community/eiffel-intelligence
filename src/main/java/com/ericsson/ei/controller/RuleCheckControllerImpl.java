package com.ericsson.ei.controller;

import java.io.IOException;
import java.util.ArrayList;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.CrossOrigin;

import com.ericsson.ei.handlers.EventHandler;
import com.ericsson.ei.handlers.EventToObjectMapHandler;
import com.ericsson.ei.jmespath.JmesPathInterface;
import com.ericsson.ei.queryservice.ProcessAggregatedObject;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;

/**
 * This class implements the Interface for JMESPath API, generated by RAML 0.8
 * Provides interaction with JmesPathInterface class
 * 
 * Usage: 1. If input contains a rule as an argument and json expression in a
 * text file, then the following curl command may be used. curl -H
 * "Content-type: application/x-www-form-urlencoded" -X POST --data-urlencode
 * jsonContent@testjson.txt
 * http://localhost:8090/jmespathrule/runRule?rule=data.outcome
 * 
 * 2. If input contains rule and json expression as two String arguments, then
 * the following curl command may be used. curl -H "Content-type:
 * application/x-www-form-urlencoded" -X POST -d
 * jsonContent={"data":{"outcome":{"conclusion":"SUCCESSFUL"},"test":"persistentLogs"}}
 * http://localhost:8090/jmespathrule/runRule?rule=data.outcome
 * 
 */

@Component
@CrossOrigin
@Api(value = "Check Rules", description ="This rest call for the execute the rule or rules(Rule object) on the Json, for checking output of rule")
public class RuleCheckControllerImpl implements RuleCheckController {

    private static final Logger LOG = LoggerFactory.getLogger(SubscriptionControllerImpl.class);

    @Autowired
    JmesPathInterface jmesPathInterface;
    
    @Autowired
    EventHandler eventHandler;
    
    @Autowired
    private ProcessAggregatedObject processAggregatedObject;
    
    @Autowired
    EventToObjectMapHandler eventToObjectMapHandler;

    /**
     * This method interacts with JmesPathInterface class method runRuleOnEvent
     * to evaluate a rule on JSON object.
     * 
     * @param rule-
     *            takes a String as a rule that need to be evaluated on JSON
     *            content
     * @param jsonContent-
     *            takes JSON object as a String
     * @return return a String object
     * 
     */
    @Override
    @CrossOrigin
    @ApiOperation(value = "run rule on event")
    public ResponseEntity<?> updateRulesRuleCheck(String rule, String jsonContent) {
        String res = new String("[]");

        try {
            JSONObject jsonObj = new JSONObject(jsonContent);
            
            String jsonString = jsonObj.toString();
            res = jmesPathInterface.runRuleOnEvent(rule, jsonString).toString();
            LOG.info("Query :" + rule + " executed Successfully");
            return new ResponseEntity<String>(res, HttpStatus.OK);

        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            return new ResponseEntity<String>(res, HttpStatus.BAD_REQUEST);
        }
    }

    @Override
    @CrossOrigin
    @ApiOperation(value = "Run the list of rules on list of events and prepare the aggregation object. This endpoint for executing the rules on list of objects and return the aggregated objects.")
    public ResponseEntity<?> updateAggregation(String listRulesJson, String listEventsJson) {

        try {
            JSONArray jsonObj = new JSONArray(listRulesJson);
            JSONArray jsonObj2 = new JSONArray(listEventsJson);
            eventHandler.getRulesHandler().setParsedJason(jsonObj.toString());
            String aggregatedObjectId = null;
            // Looping all events and add suffix template name to id and links, For identifying the test aggregated events.
            for (int i = 0; i < jsonObj2.length(); i++) {
                String templateName = jmesPathInterface
                        .runRuleOnEvent("TemplateName", jsonObj.getJSONObject(0).toString()).asText("TEST");
                String addTemplateNameToIds = addTemplateNameToIds(jsonObj2.getJSONObject(i), templateName);
                LOG.info("event to prepare aggregated object :: " + jsonObj2.getJSONObject(i).toString());
                if (aggregatedObjectId == null) {
                    aggregatedObjectId = addTemplateNameToIds;
                }
                eventHandler.eventReceived(jsonObj2.getJSONObject(i).toString());
            }

            if (aggregatedObjectId != null) {
                ArrayList<String> response = processAggregatedObject.processQueryAggregatedObject(aggregatedObjectId);
                // Delete the aggregated object
                processAggregatedObject.deleteAggregatedObject(aggregatedObjectId);
                // Delete the event object mapper
                eventToObjectMapHandler.deleteEventObjectMap(aggregatedObjectId);
                return new ResponseEntity<String>(response.toString(), HttpStatus.OK);
            } else {
                return new ResponseEntity<String>("invalid json content", HttpStatus.BAD_REQUEST);
            }

        } catch (JSONException | IOException e) {
            LOG.error(e.getMessage(), e);
            return new ResponseEntity<String>("invalid json content", HttpStatus.BAD_REQUEST);
        }
    }

    private String addTemplateNameToIds(JSONObject jsonObject, String templateName) throws JSONException {
        String idTemplateSuffix = jmesPathInterface.runRuleOnEvent("meta.id", jsonObject.toString()).asText() + "_" + templateName;
        jsonObject.getJSONObject("meta").put("id", idTemplateSuffix);
        for (int i = 0; i < jsonObject.getJSONArray("links").length(); i++) {
            JSONObject link = jsonObject.getJSONArray("links").getJSONObject(i);
            link.put("target",link.getString("target") + "_" + templateName);
        }
        return idTemplateSuffix;
    }


}
